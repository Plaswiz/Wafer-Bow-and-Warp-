import os
import re
import pandas as pd
import tkinter as tk
from tkinter import (
    filedialog, messagebox, Button, Label, Frame, Listbox,
    Scrollbar, Text, Entry, Checkbutton, IntVar
)
from tkinter import ttk
from scipy.interpolate import griddata
import numpy as np
import logging
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
from openpyxl.formatting.rule import CellIsRule
import plotly.graph_objects as go

from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

# Increase logging detail for debugging
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")


# ------------------------------------------------------------------------------
# 1) "Smart" Extract Logic (left-to-right for '4')
# ------------------------------------------------------------------------------
def smart_extract_lot_wafer(path: str):
    logging.debug(f"[smart_extract_lot_wafer] Checking path: {path}")
    parts = path.split(os.sep)
    if not parts:
        logging.debug("... no parts => (None,None)")
        return (None, None)

    lotIndex = None
    for i, part in enumerate(parts):
        if part.startswith('4'):
            lotIndex = i
            logging.debug(f"Found subfolder w/ '4': {part} at index={i}")
            break
    if lotIndex is None:
        logging.debug("... no '4' => (None,None).")
        return (None, None)

    lotCandidate = parts[lotIndex]
    dotPos = lotCandidate.find('.')
    if dotPos > 0:
        lotPart = lotCandidate[:dotPos]
        waferPart = lotCandidate[dotPos+1:]
        if waferPart.isdigit():
            logging.debug(f"Parsed lot={lotPart}, wafer={waferPart} from {lotCandidate}")
            return (lotPart, waferPart)
        else:
            logging.debug(f"{lotCandidate} has dot but suffix not numeric => keep scanning subfolders.")
            lotCandidate = lotPart

    # Scan subsequent parts for wafer
    for j in range(lotIndex+1, len(parts)):
        candidate = parts[j]
        if candidate.isdigit():
            logging.debug(f"Found wafer={candidate} in next subfolder after {lotCandidate}")
            return (lotCandidate, candidate)
        dot2 = candidate.find('.')
        if dot2 != -1:
            suffix = candidate[dot2+1:]
            if suffix.isdigit():
                logging.debug(f"Found wafer suffix={suffix} in folder={candidate}")
                return (lotCandidate, suffix)

    logging.debug(f"No wafer => returning (lotCandidate={lotCandidate}, None)")
    return (lotCandidate, None)


# ------------------------------------------------------------------------------
# 2) "find_lot_wafer_upwards" – climb upward from file directory
# ------------------------------------------------------------------------------
def find_lot_wafer_upwards(start_dir: str):
    logging.info(f"[find_lot_wafer_upwards] Climb upward from: {start_dir}")
    current = start_dir
    while True:
        if not current or not os.path.isdir(current):
            logging.debug(f"... {current} is invalid => (None,None)")
            return (None, None)

        all_items = os.listdir(current)
        all_items.sort(reverse=True)
        logging.debug(f"At {current}, subfolders => {all_items} (reverse sorted)")

        for p in all_items:
            candidate_path = os.path.join(current, p)
            if os.path.isdir(candidate_path) and p.startswith('4'):
                logging.debug(f"Trying candidate subfolder => {candidate_path}")
                lot, wafer = smart_extract_lot_wafer(candidate_path)
                if lot:
                    logging.info(f"Found lot={lot}, wafer={wafer} in {candidate_path}")
                    return (lot, wafer)

        parent = os.path.dirname(current)
        if not parent or parent == current:
            logging.debug(f"Reached root from {current} => (None,None).")
            return (None, None)
        logging.debug(f"No '4...' subfolder in {current}, going up to {parent}")
        current = parent


# ------------------------------------------------------------------------------
# 3) Plane Fitting, Bow, Warp
# ------------------------------------------------------------------------------
def fit_plane(points, values):
    radius = np.sqrt(points[:, 0]**2 + points[:, 1]**2)
    outer_pts = points[radius > 80]
    outer_vals = values[radius > 80]
    if len(outer_pts) < 3:
        logging.error("Not enough outer points to fit a plane.")
        raise ValueError("Insufficient outer points.")
    A = np.c_[outer_pts[:, 0], outer_pts[:, 1], np.ones(outer_pts.shape[0])]
    C, *_ = np.linalg.lstsq(A, outer_vals, rcond=None)
    return C

def remove_plane(points, values, coeffs):
    return values - (coeffs[0]*points[:, 0] + coeffs[1]*points[:, 1] + coeffs[2])

def calculate_bow_warp(points, corrected):
    center_val = griddata(points, corrected, ([0],[0]), method='linear')[0]
    bow = (np.mean(corrected) - center_val)*1000
    warp = np.ptp(corrected)*1000
    return round(bow,1), round(warp,1)


# ------------------------------------------------------------------------------
# 4) Generate Heatmap
# ------------------------------------------------------------------------------
def generate_heatmap(points, corrected_values_mm, bow, warp, lot, wafer, output_folder, interp_method):
    corrected_um = corrected_values_mm * 1000.0
    grid_res = 200
    x = np.linspace(points[:,0].min(), points[:,0].max(), grid_res)
    y = np.linspace(points[:,1].min(), points[:,1].max(), grid_res)
    xg, yg = np.meshgrid(x, y)
    zg = griddata(points, corrected_um, (xg, yg), method=interp_method)

    fig = go.Figure(
        data=go.Heatmap(
            x=x,
            y=y,
            z=zg,
            colorscale='Viridis',
            colorbar=dict(title="Corrected Z [microns]", tickformat=".2f"),
        )
    )
    fig.update_layout(
        title=f"Wafer Heatmap<br>Bow: {bow:.1f} µm | Warp: {warp:.1f} µm",
        xaxis_title="X Coordinate",
        yaxis_title="Y Coordinate",
        xaxis=dict(scaleanchor="y", scaleratio=1),
        yaxis=dict(scaleanchor="x", scaleratio=1)
    )

    # Note the extra underscore between wafer & "heatmap"
    filename = f"{lot}_{wafer}_heatmap.html"
    out_file = os.path.join(output_folder, filename)
    fig.write_html(out_file)
    logging.info(f"Heatmap saved as {out_file}")


# ------------------------------------------------------------------------------
# 5) File Reading, Data Analysis
# ------------------------------------------------------------------------------
def sieve(topfolder, pattern=r'Run\d+\.txt'):
    matches = []
    for base, _, files in os.walk(topfolder):
        for f in files:
            if re.search(pattern, f, re.IGNORECASE):
                full = os.path.join(base, f)
                matches.append(full)
    return matches

def read_txt_files(file_list, lot, wafer):
    data_list = []
    for fp in file_list:
        if 'ReferenceChipSingleBeam' in fp:
            continue
        if not fp.lower().endswith('.txt'):
            continue
        try:
            df = pd.read_csv(fp, delimiter=',', header=0, skipinitialspace=True)
            if all(c in df.columns for c in ['X','Y','Z']):
                sub = df[['X','Y','Z']].copy()
                sub['Lot'] = lot
                sub['Wafer'] = wafer
                data_list.append(sub)
                logging.debug(f"read_txt_files: appended data from {fp} => lot={lot}, wafer={wafer}")
            else:
                logging.warning(f"{fp} missing X,Y,Z.")
        except Exception as e:
            logging.error(f"Error reading {fp}: {e}")
    return pd.concat(data_list, ignore_index=True) if data_list else pd.DataFrame()

def analyze_data(data):
    if data.empty:
        return None
    pts = data[['X','Y']].values
    vals_mm = data['Z'].values
    coeffs = fit_plane(pts, vals_mm)
    corrected = remove_plane(pts, vals_mm, coeffs)
    std_dev = np.std(vals_mm)
    bow, warp = calculate_bow_warp(pts, corrected)
    return std_dev, bow, warp, pts, corrected


# ------------------------------------------------------------------------------
# 6) Custom Save Routines (No prompt)
# ------------------------------------------------------------------------------
def save_combined_data_autoname(big_df, output_folder, base_name):
    """
    Saves combined X,Y,Z data to <output_folder>/<base_name>.csv
    """
    if not output_folder:
        logging.warning("No output folder specified for combined data.")
        return
    if not base_name:
        base_name = "xyz_data"

    fname = os.path.join(output_folder, f"{base_name}.csv")
    if 'Wafer' in big_df.columns:
        big_df['Wafer'] = pd.to_numeric(big_df['Wafer'], errors='coerce')
    if 'Lot' in big_df.columns:
        big_df['Lot'] = big_df['Lot'].astype(str)
    if 'Lot' in big_df.columns and 'Wafer' in big_df.columns:
        big_df.sort_values(by=['Lot','Wafer'], inplace=True, ignore_index=True)

    big_df.to_csv(fname, index=False, encoding='utf-8-sig')
    logging.info(f"Combined data saved as {fname}")


def save_results_autoname(results, threshold, output_folder, base_name):
    """
    Saves Bow/Warp results to <output_folder>/<base_name>.xlsx
    """
    if not output_folder:
        logging.warning("No output folder for results.")
        return
    if not base_name:
        base_name = "analysis_results"

    fname = os.path.join(output_folder, f"{base_name}.xlsx")

    df = pd.DataFrame(results)
    if 'Wafer' in df.columns:
        df['Wafer'] = pd.to_numeric(df['Wafer'], errors='coerce')
    if 'Lot' in df.columns:
        df['Lot'] = df['Lot'].astype(str)
    if 'Lot' in df.columns and 'Wafer' in df.columns:
        df.sort_values(by=['Lot','Wafer'], inplace=True, ignore_index=True)

    df.to_excel(fname, index=False)
    wb = load_workbook(fname)
    ws = wb.active

    bow_col, warp_col = None, None
    for col in ws.iter_cols(1, ws.max_column):
        if col[0].value == "Bow (µm)":
            bow_col = col[0].column_letter
        elif col[0].value == "Warp (µm)":
            warp_col = col[0].column_letter

    from openpyxl.styles import PatternFill
    red_fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")
    from openpyxl.formatting.rule import CellIsRule

    if bow_col:
        ws.conditional_formatting.add(
            f"{bow_col}2:{bow_col}{ws.max_row}",
            CellIsRule(operator="greaterThanOrEqual", formula=[str(threshold)], fill=red_fill)
        )
        ws.conditional_formatting.add(
            f"{bow_col}2:{bow_col}{ws.max_row}",
            CellIsRule(operator="lessThanOrEqual", formula=[str(-threshold)], fill=red_fill)
        )
    if warp_col:
        ws.conditional_formatting.add(
            f"{warp_col}2:{warp_col}{ws.max_row}",
            CellIsRule(operator="greaterThanOrEqual", formula=[str(threshold)], fill=red_fill)
        )

    wb.save(fname)
    logging.info(f"Results saved as {fname}")


# ------------------------------------------------------------------------------
# 7) The GUI
# ------------------------------------------------------------------------------
class FolderSelectorApp:
    def __init__(self, root):
        self.root = root
        self.root.geometry("800x650")
        self.root.title("Warpspeed Analysis Tool v2.0")

        self.selected_folders = []
        self.selected_files = []
        self.output_folder = None
        self.heatmap_var = IntVar(value=1)
        self.interp_var = tk.StringVar(value="cubic")

        self.create_widgets()
        self.worker_thread = None

    def create_widgets(self):
        # Top frame => Add folder, add file
        top_frame = Frame(self.root)
        top_frame.pack(pady=5)

        Button(top_frame, text="Add Folder", command=self.add_folder).grid(row=0, column=0, padx=5)
        Button(top_frame, text="Add Text File", command=self.add_file).grid(row=0, column=1, padx=5)

        Label(self.root, text="Selected Folders / Files:").pack()
        f_frame = Frame(self.root)
        f_frame.pack()
        self.listbox = Listbox(f_frame, width=70, height=10)
        self.listbox.pack(side="left", fill="both", expand=True)
        sb = Scrollbar(f_frame, orient="vertical", command=self.listbox.yview)
        sb.pack(side="right", fill="y")
        self.listbox.config(yscrollcommand=sb.set)

        Button(self.root, text="Remove Selected", command=self.remove_item).pack(pady=5)

        # USL
        thr_frame = Frame(self.root)
        thr_frame.pack(pady=5)
        Label(thr_frame, text="USL [micron]:").pack(side="left")
        self.threshold_entry = Entry(thr_frame, width=10)
        self.threshold_entry.pack(side="left", padx=5)
        self.threshold_entry.insert(0, "100.0")

        # Output folder
        outf = Frame(self.root)
        outf.pack(pady=5)
        Label(outf, text="Output Folder:").pack(side="left")
        Button(outf, text="Select Folder", command=self.select_output_folder).pack(side="left", padx=5)

        # Checkbutton => 2D Heatmaps
        Checkbutton(self.root, text="Generate 2D Heatmaps?", variable=self.heatmap_var).pack()

        # Interpolation
        Label(self.root, text="2D Heatmap Interpolation:").pack()
        self.interp_combo = ttk.Combobox(self.root, textvariable=self.interp_var,
                                         values=["cubic","linear"], width=15)
        self.interp_combo.pack()
        self.interp_combo.current(0)

        # Add text fields for the file base names
        file_label_frame = Frame(self.root)
        file_label_frame.pack(pady=5)

        Label(file_label_frame, text="XYZ File Name:").grid(row=0, column=0, sticky="e", padx=5)
        self.xyz_entry = Entry(file_label_frame, width=20)
        self.xyz_entry.insert(0, "xyz")  # default
        self.xyz_entry.grid(row=0, column=1, padx=5)

        Label(file_label_frame, text="Bow/Warp File Name:").grid(row=1, column=0, sticky="e", padx=5)
        self.analysis_entry = Entry(file_label_frame, width=20)
        self.analysis_entry.insert(0, "analysis_results")  # default
        self.analysis_entry.grid(row=1, column=1, padx=5)

        # Description text
        self.desc_txt = Text(self.root, height=4, width=80)
        self.desc_txt.pack(pady=5)
        self.desc_txt.insert(
            "end",
            "• Bow is (mean of plane-corrected surface) - center, in microns.\n"
            "• Warp is the peak-to-peak range of the plane-corrected surface, in microns.\n"
        )
        self.desc_txt.config(state="disabled")

        # Progress
        self.prog_label = Label(self.root, text="Progress: 0%")
        self.prog_label.pack()
        self.prog_bar = ttk.Progressbar(self.root, orient="horizontal", length=500, mode="determinate")
        self.prog_bar.pack(pady=5)

        # Bottom
        bot_frame = Frame(self.root)
        bot_frame.pack(pady=5)
        self.run_btn = Button(bot_frame, text="Run Analysis", command=self.start_analysis)
        self.run_btn.pack(side="left", padx=10)
        Button(bot_frame, text="Exit", command=self.root.quit).pack(side="left", padx=10)

        Label(self.root, text="Reference Memo: lund-1", fg="gray").pack(side="bottom", pady=5)

    # ---------------------
    # Folder/File Add/Remove
    # ---------------------
    def add_folder(self):
        folder = filedialog.askdirectory(mustexist=True, title="Select Folder")
        if folder and folder not in self.selected_folders:
            self.selected_folders.append(folder)
            self.listbox.insert("end", "[Folder] " + folder)
            logging.info(f"Add Folder => {folder}")

    def add_file(self):
        f = filedialog.askopenfilename(title="Select .txt File", filetypes=[("Text Files","*.txt")])
        if f and f not in self.selected_files:
            self.selected_files.append(f)
            self.listbox.insert("end", "[File] " + f)
            logging.info(f"Add File => {f}")

    def remove_item(self):
        sel = self.listbox.curselection()
        for i in reversed(sel):
            val = self.listbox.get(i)
            if val.startswith("[Folder]"):
                path = val.replace("[Folder] ","")
                if path in self.selected_folders:
                    self.selected_folders.remove(path)
            elif val.startswith("[File]"):
                path = val.replace("[File] ","")
                if path in self.selected_files:
                    self.selected_files.remove(path)
            self.listbox.delete(i)

    def select_output_folder(self):
        self.output_folder = filedialog.askdirectory(mustexist=True, title="Select Output Folder")
        if self.output_folder:
            logging.info(f"Selected output folder: {self.output_folder}")

    # ---------------------
    # Progress
    # ---------------------
    def reset_progress(self):
        self.prog_label.config(text="Progress: 0%")
        self.prog_bar["value"] = 0
        self.root.update_idletasks()

    def update_progress(self, current, total):
        pct = int((current / total)*100)
        self.prog_label.config(text=f"Progress: {pct}%")
        self.prog_bar["value"] = pct
        self.root.update_idletasks()

    # ---------------------
    # Main Analysis
    # ---------------------
    def start_analysis(self):
        if not self.selected_folders and not self.selected_files:
            messagebox.showerror("Error","No folders/files selected.")
            return
        if not self.output_folder:
            messagebox.showerror("Error","No output folder selected.")
            return

        self.run_btn.config(state="disabled")
        self.worker_thread = threading.Thread(target=self.run_analysis)
        self.worker_thread.start()

    def run_analysis(self):
        thr_str = self.threshold_entry.get()
        try:
            threshold = float(thr_str)
        except ValueError:
            threshold = 100.0  # default

        # Gather user-supplied filenames
        xyz_basename = self.xyz_entry.get().strip()
        analysis_basename = self.analysis_entry.get().strip()

        items = self.gather_wafer_items()
        total = len(items)
        if total == 0:
            logging.info("No wafer items found after gather_wafer_items.")
            self.finish_analysis()
            return

        all_frames = []
        results = []
        hm_info = []

        with ThreadPoolExecutor() as ex:
            future_map = {}
            for witem in items:
                fut = ex.submit(self.process_item, witem)
                future_map[fut] = witem

            done_cnt = 0
            for fut in as_completed(future_map):
                try:
                    out = fut.result()
                    if out:
                        df_data, wafer_res, hm_data = out
                        if not df_data.empty:
                            all_frames.append(df_data)
                        if wafer_res:
                            results.append(wafer_res)
                        if hm_data:
                            hm_info.append(hm_data)
                except Exception as e:
                    logging.error(f"Error analyzing item: {e}")
                done_cnt += 1
                self.update_progress(done_cnt, total)

        # Save combined data => no user prompt, use "xyz_basename"
        if all_frames:
            comb_df = pd.concat(all_frames, ignore_index=True)
            save_combined_data_autoname(comb_df, self.output_folder, xyz_basename)

        # Save numeric results => no user prompt, use "analysis_basename"
        if results:
            save_results_autoname(results, threshold, self.output_folder, analysis_basename)

        # Heatmaps
        if self.heatmap_var.get() == 1 and hm_info:
            self.reset_progress()
            total_maps = len(hm_info)
            current_map = 0
            chosen_method = self.interp_var.get()
            for (lot, wafer, pts, corr_vals, bow, warp) in hm_info:
                # pass the chosen method to generate_heatmap
                # underscore wafer & "heatmap"
                corrected_um = corr_vals
                generate_heatmap(pts, corrected_um, bow, warp, lot, wafer, self.output_folder, chosen_method)
                current_map += 1
                self.update_progress(current_map, total_maps)

        self.finish_analysis()

    def finish_analysis(self):
        self.update_progress(1,1)
        logging.info("Analysis complete.")
        messagebox.showinfo("Done","Analysis complete.")
        self.run_btn.config(state="normal")
        # Reset progress bar after analysis completes
        self.reset_progress()

    # ---------------------
    # Gathering Wafers
    # ---------------------
    def gather_wafer_items(self):
        encountered = {}

        for fdir in self.selected_folders:
            logging.debug(f"[gather_wafer_items] Folder => {fdir}")
            for root, dirs, _ in os.walk(fdir):
                for d in dirs:
                    subp = os.path.join(root, d)
                    lot, wafer = smart_extract_lot_wafer(subp)
                    if not lot:
                        continue
                    txt_files = sieve(subp, r'Run\d+\.txt')
                    if not txt_files:
                        continue

                    # If wafer is None, see if sub-subfolders yield a real wafer
                    if wafer is None:
                        deeper_wafer = self.check_subfolders_for_wafer(subp)
                        if deeper_wafer:
                            logging.debug(f"Skipping partial lot={lot} subp={subp} because deeper subfolder has wafer={deeper_wafer}")
                            continue
                        wafer = "Unknown"

                    key = (lot, wafer)
                    if key not in encountered:
                        encountered[key] = set()
                    for fp in txt_files:
                        encountered[key].add(fp)

        for single_fp in self.selected_files:
            logging.debug(f"[gather_wafer_items] Single file => {single_fp}")
            start_dir = os.path.dirname(single_fp)
            lot, wafer = find_lot_wafer_upwards(start_dir)
            if not lot:
                lot = "Unknown"
            if not wafer:
                wafer = "Unknown"
            key = (lot, wafer)
            if key not in encountered:
                encountered[key] = set()
            encountered[key].add(single_fp)

        witems = []
        for (lot, wafer), filepaths in encountered.items():
            logging.debug(f"Final dictionary => lot={lot}, wafer={wafer}, #files={len(filepaths)}")
            witems.append({
                'lot': lot,
                'wafer': wafer,
                'files': list(filepaths)
            })
        return witems

    def check_subfolders_for_wafer(self, folder):
        for root, dirs, _ in os.walk(folder):
            for d in dirs:
                subp = os.path.join(root, d)
                _, sub_wafer = smart_extract_lot_wafer(subp)
                if sub_wafer is not None:
                    return sub_wafer
        return None

    def process_item(self, wdict):
        lot = wdict['lot']
        wafer = wdict['wafer']
        flist = wdict['files']
        logging.debug(f"[process_item] lot={lot}, wafer={wafer}, #files={len(flist)}")

        df_data = read_txt_files(flist, lot, wafer)
        if df_data.empty:
            logging.info(f"No valid data for {lot}/{wafer}")
            return None

        result = analyze_data(df_data)
        if result:
            std_dev, bow, warp, pts, corr = result
            wafer_res = {
                "Lot": lot,
                "Wafer": wafer,
                "Std Dev": std_dev,
                "Bow (µm)": bow,
                "Warp (µm)": warp
            }
            hm = (lot, wafer, pts, corr, bow, warp)
            return (df_data, wafer_res, hm)
        return None


# ---------------------
# Replacements for file dialogs
# ---------------------
def save_combined_data_autoname(big_df, output_folder, base_name):
    if not output_folder:
        logging.warning("No output folder specified for combined data.")
        return
    if not base_name:
        base_name = "xyz_data"

    fname = os.path.join(output_folder, f"{base_name}.csv")
    if 'Wafer' in big_df.columns:
        big_df['Wafer'] = pd.to_numeric(big_df['Wafer'], errors='coerce')
    if 'Lot' in big_df.columns:
        big_df['Lot'] = big_df['Lot'].astype(str)
    if 'Lot' in big_df.columns and 'Wafer' in big_df.columns:
        big_df.sort_values(by=['Lot','Wafer'], inplace=True, ignore_index=True)

    big_df.to_csv(fname, index=False, encoding='utf-8-sig')
    logging.info(f"Combined data saved as {fname}")

def save_results_autoname(results, threshold, output_folder, base_name):
    if not output_folder:
        logging.warning("No output folder for results.")
        return
    if not base_name:
        base_name = "analysis_results"

    fname = os.path.join(output_folder, f"{base_name}.xlsx")
    df = pd.DataFrame(results)
    if 'Wafer' in df.columns:
        df['Wafer'] = pd.to_numeric(df['Wafer'], errors='coerce')
    if 'Lot' in df.columns:
        df['Lot'] = df['Lot'].astype(str)
    if 'Lot' in df.columns and 'Wafer' in df.columns:
        df.sort_values(by=['Lot','Wafer'], inplace=True, ignore_index=True)

    df.to_excel(fname, index=False)
    wb = load_workbook(fname)
    ws = wb.active

    bow_col, warp_col = None, None
    for col in ws.iter_cols(1, ws.max_column):
        if col[0].value == "Bow (µm)":
            bow_col = col[0].column_letter
        elif col[0].value == "Warp (µm)":
            warp_col = col[0].column_letter

    from openpyxl.styles import PatternFill
    red_fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")
    from openpyxl.formatting.rule import CellIsRule

    if bow_col:
        ws.conditional_formatting.add(
            f"{bow_col}2:{bow_col}{ws.max_row}",
            CellIsRule(operator="greaterThanOrEqual", formula=[str(threshold)], fill=red_fill)
        )
        ws.conditional_formatting.add(
            f"{bow_col}2:{bow_col}{ws.max_row}",
            CellIsRule(operator="lessThanOrEqual", formula=[str(-threshold)], fill=red_fill)
        )
    if warp_col:
        ws.conditional_formatting.add(
            f"{warp_col}2:{warp_col}{ws.max_row}",
            CellIsRule(operator="greaterThanOrEqual", formula=[str(threshold)], fill=red_fill)
        )

    wb.save(fname)
    logging.info(f"Results saved as {fname}")


def run_gui():
    root = tk.Tk()
    app = FolderSelectorApp(root)
    root.mainloop()


if __name__ == "__main__":
    run_gui()
